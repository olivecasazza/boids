<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WASM Flock Demo</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            font-family: system-ui, -apple-system, sans-serif;
        }
        canvas {
            border: 1px solid black;
            background: #f0f0f0;
        }
        .controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #flock-size {
            width: 200px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div class="controls">
        <label for="flock-size">Flock Size:</label>
        <input type="range" id="flock-size" min="1" max="3000" value="50">
        <span id="size-display">50 / 3000</span>

    </div>
    <script type="module" >
        import init, { Flock, Species } from './pkg/wasm_flock.js';

        async function run() {
            await init();

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            const MAX_BOIDS = 3000;
            const BOIDS_PER_SPECIES = 50;
            
            // Create flock with default species
            const flock = new Flock(canvas.width, canvas.height, BOIDS_PER_SPECIES);
            
            // Add two random species
            const randomSpecies1 = Species.random();
            const randomSpecies2 = Species.random();
            
            const species1Id = flock.add_species(randomSpecies1);
            const species2Id = flock.add_species(randomSpecies2);
            
            // Add boids for each random species
            flock.add_boids(BOIDS_PER_SPECIES, species1Id);
            flock.add_boids(BOIDS_PER_SPECIES, species2Id);

            // Handle mouse clicks to add boids
            canvas.addEventListener('mousedown', (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                // If we're at max capacity, remove a random boid first
                if (flock.len() >= MAX_BOIDS) {
                    flock.remove_random_boid();
                }

                // Add a new boid at the clicked position with a random species
                const speciesIds = [0, species1Id, species2Id];
                const randomSpeciesId = speciesIds[Math.floor(Math.random() * speciesIds.length)];
                flock.add_boid_at(x, y, randomSpeciesId);

                // Update the size display
                sizeDisplay.textContent = `${flock.len()} / ${MAX_BOIDS}`;
            });

            // Setup slider control
            const sizeSlider = document.getElementById('flock-size');
            const sizeDisplay = document.getElementById('size-display');
            
            sizeSlider.addEventListener('input', () => {
                const targetSizePerSpecies = Math.floor(parseInt(sizeSlider.value) / 3);
                flock.set_size(targetSizePerSpecies * 3); // Maintain equal distribution
                sizeDisplay.textContent = `${targetSizePerSpecies * 3} / ${MAX_BOIDS}`;
            });

            // Performance monitoring
            let lastTime = performance.now();
            let frames = 0;
            let fpsDisplay = document.createElement('div');
            document.body.appendChild(fpsDisplay);

            // Timing breakdown
            let updateTime = 0;
            let drawTime = 0;
            let timingDisplay = document.createElement('div');
            document.body.appendChild(timingDisplay);

            function draw() {
                const now = performance.now();
                frames++;
                
                if (now - lastTime > 1000) {
                    fpsDisplay.textContent = `FPS: ${frames}`;
                    timingDisplay.textContent = `Update: ${updateTime.toFixed(2)}ms | Draw: ${drawTime.toFixed(2)}ms`;
                    frames = 0;
                    lastTime = now;
                }

                const updateStart = performance.now();
                flock.update();
                updateTime = performance.now() - updateStart;

                const drawStart = performance.now();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const positions = flock.get_boids();
                
                // Group boids by color for batch rendering
                const colorGroups = new Map();
                
                for (let i = 0; i < positions.length; i += 7) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    const size = positions[i + 2];
                    const color = `rgba(${
                        Math.floor(positions[i + 3] * 255)},${
                        Math.floor(positions[i + 4] * 255)},${
                        Math.floor(positions[i + 5] * 255)},${
                        positions[i + 6]})`;
                    
                    if (!colorGroups.has(color)) {
                        colorGroups.set(color, []);
                    }
                    colorGroups.get(color).push({x, y, size});
                }
                
                // Batch render boids by color
                for (const [color, boids] of colorGroups) {
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    for (const {x, y, size} of boids) {
                        ctx.moveTo(x + size, y);
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                    }
                    ctx.fill();
                }

                drawTime = performance.now() - drawStart;
                requestAnimationFrame(draw);
            }

            draw();
        }

        run();
    </script>
</body>
</html>
